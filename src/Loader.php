<?php
/**
 * This file is a part of the phpMussel\Core package.
 * Homepage: https://phpmussel.github.io/
 *
 * PHPMUSSEL COPYRIGHT 2013 AND BEYOND BY THE PHPMUSSEL TEAM.
 *
 * License: GNU/GPLv2
 * @see LICENSE.txt
 *
 * This file: The loader (last modified: 2023.06.01).
 */

namespace phpMussel\Core;

class Loader
{
    /**
     * @var string The path to phpMussel's configuration file.
     */
    public $ConfigurationPath = '';

    /**
     * @var array phpMussel's configuration data.
     */
    public $Configuration = [];

    /**
     * @var array phpMussel's configuration defaults.
     */
    public $ConfigurationDefaults = [];

    /**
     * @var string The path to phpMussel's cache data.
     */
    public $CachePath = '';

    /**
     * @var string The path to phpMussel's quarantine.
     */
    public $QuarantinePath = '';

    /**
     * @var string The path to phpMussel's signature files.
     */
    public $SignaturesPath = '';

    /**
     * @var string The path to an optional greylist file.
     */
    public $GreylistPath = '';

    /**
     * @var \Maikuolan\Common\YAML An object for handling YAML data.
     */
    public $YAML;

    /**
     * @var \Maikuolan\Common\Events An object for orchestrating events.
     */
    public $Events;

    /**
     * @var \Maikuolan\Common\Request An object for sending cURL requests.
     */
    public $Request;

    /**
     * @var \Maikuolan\Common\L10N An object for handling configuration-defined L10N data.
     */
    public $L10N;

    /**
     * @var string Which configuration-defined language was accepted by phpMussel.
     */
    public $L10NAccepted = '';

    /**
     * @var \Maikuolan\Common\L10N An object for handling client-defined L10N data.
     */
    public $ClientL10N;

    /**
     * @var string Which client-defined language was accepted by phpMussel (if any).
     */
    public $ClientL10NAccepted = '';

    /**
     * @var \Maikuolan\Common\Cache An object for handling cache data.
     */
    public $Cache;

    /**
     * @var string phpMussel version number (SemVer).
     */
    public $ScriptVersion = '3.4.0';

    /**
     * @var string phpMussel version identifier (complete notation).
     */
    public $ScriptIdent = 'phpMussel v%s';

    /**
     * @var string phpMussel user agent (for external requests).
     */
    public $ScriptUA = '%s (https://phpmussel.github.io/)';

    /**
     * @var int When the object was instantiated.
     */
    public $Time = 0;

    /**
     * @var array Used as a soft-cache for just the specific object instance.
     */
    public $InstanceCache = ['LogPaths' => []];

    /**
     * @var array Used for logging any errors generated by phpMussel.
     */
    public $Errors = [];

    /**
     * @var array Contains scan results as human-readable text.
     */
    public $ScanResultsText = [];

    /**
     * @var array Contains scan results as integers.
     */
    public $ScanResultsIntegers = [];

    /**
     * @var string Contains scan results formatted for use by CLI and elsewhere.
     */
    public $ScanResultsFormatted = '';

    /**
     * @var string If the file being scanned happens to be a PE file, references to
     *      the individual PE sections of the files in question will be appended
     *      here.
     */
    public $PEData = '';

    /**
     * @var string Contains references to any files flagged during the scan in the
     *      form of "HASH:FILESIZE:FILENAME".
     */
    public $HashReference = '';

    /**
     * @var int Populated by the request method.
     */
    public $MostRecentHttpCode = 0;

    /**
     * @var string The IP address the instance is working with.
     */
    public $IPAddr = '';

    /**
     * @var string The path to the core asset files.
     */
    private $AssetsPath = __DIR__ . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . 'assets' . DIRECTORY_SEPARATOR;

    /**
     * @var string The path to the core L10N files.
     */
    private $L10NPath = __DIR__ . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . 'l10n' . DIRECTORY_SEPARATOR;

    /**
     * @var array Channels information for request.
     */
    private $Channels = [];

    /**
     * @var int The default blocksize for readFileContent and readFileContentGZ.
     */
    private $Blocksize = 131072;

    /**
     * @var string Safety mechanism for logging events.
     */
    public const SAFETY = "\x3C\x3Fphp die; \x3F\x3E";

    /**
     * Construct the loader.
     *
     * @param string $ConfigurationPath Custom-defined path to phpMussel's
     *      configuration file (optional).
     * @param string $CachePath An optional, custom-defined path to phpMussel's
     *      cache data (this is also where files may be stored temporarily when
     *      it's needed).
     * @param string $QuarantinePath An optional, custom-defined path to
     *      phpMussel's quarantine directory.
     * @param string $SignaturesPath An optional, custom-defined path to
     *      phpMussel's signature files.
     * @param string $VendorPath An optional, custom-defined path to the vendor
     *      directory.
     * @throws Exception if the PHP version requirements aren't met, if the
     *      vendor directory can't be located, or if the phpMussel
     *      configuration file can't be located.
     * @return void
     */
    public function __construct(
        string $ConfigurationPath = '',
        string $CachePath = '',
        string $QuarantinePath = '',
        string $SignaturesPath = '',
        string $VendorPath = ''
    ) {
        /** Ensure minimum PHP version requirement is met. */
        if (!version_compare(PHP_VERSION, '7.2.0', '>=')) {
            throw new \Exception('phpMussel v3 requires PHP >= 7.2.0 in order to work properly.');
        }

        /** Fallback to try for undefined VendorPath. */
        if (!$VendorPath) {
            $VendorPath = __DIR__ . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . 'vendor';
        }

        /** The specified vendor directory doesn't exist or isn't readable. */
        if (!is_dir($VendorPath) || !is_readable($VendorPath)) {
            if (isset($_SERVER['DOCUMENT_ROOT'], $_SERVER['SCRIPT_NAME'])) {
                /** Safeguard for symlinked installations. */
                $VendorPath = $this->buildPath(dirname($_SERVER['DOCUMENT_ROOT'] . $_SERVER['SCRIPT_NAME']) . DIRECTORY_SEPARATOR . 'vendor', false);

                /** Eep.. Still not working. Generate exception. */
                if ($VendorPath === '' || !is_dir($VendorPath) || !is_readable($VendorPath)) {
                    throw new \Exception('Vendor directory is undefined or unreadable.');
                }
            } else {
                /** Further safeguards not possible. Generate exception. */
                throw new \Exception('Vendor directory is undefined or unreadable.');
            }
        }

        /** Prepare the phpMussel version identifier. */
        $this->ScriptIdent = sprintf($this->ScriptIdent, $this->ScriptVersion);

        /** Prepare the phpMussel user agent. */
        $this->ScriptUA = sprintf($this->ScriptUA, $this->ScriptIdent);

        /** Instantiate YAML object. */
        $this->YAML = new \Maikuolan\Common\YAML();

        /** Make configuration referable by YAML object. */
        $this->YAML->Refs['Config Defaults'] = &$this->ConfigurationDefaults;

        /** Instantiate events orchestrator. */
        $this->Events = new \Maikuolan\Common\Events();

        /** Needed for referencing. */
        $Errors = &$this->Errors;
        $Events = &$this->Events;

        /**
         * An error handler to catch any errors generated by phpMussel when needed.
         * @link https://php.net/set_error_handler
         *
         * @param int $errno
         * @param string $errstr
         * @param string $errfile
         * @param int $errline
         * @return bool True to end further processing; False to defer processing.
         * @return callable
         */
        set_error_handler(function ($errno, $errstr, $errfile, $errline) use (&$Errors, &$Events) {
            $Errors[] = [$errno, $errstr, $errfile, $errline];
            if ($Events->assigned('error')) {
                $Events->fireEvent('error', '', $errno, $errstr, $errfile, $errline);
            }
        });

        /** Calculate configuration path. */
        if ($ConfigurationPath && is_readable($ConfigurationPath)) {
            $this->ConfigurationPath = $ConfigurationPath;
        } elseif ($VendorPath && is_readable($VendorPath . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . 'phpmussel.ini')) {
            $this->ConfigurationPath = $VendorPath . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . 'phpmussel.ini';
        } elseif ($VendorPath && is_readable($VendorPath . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . 'phpmussel.yml')) {
            $this->ConfigurationPath = $VendorPath . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . 'phpmussel.yml';
        } else {
            throw new \Exception('Unable to locate phpMussel\'s configuration file.');
        }

        /** Read the phpMussel configuration file. */
        if (strtolower(substr($this->ConfigurationPath, -4)) === '.ini') {
            $this->Configuration = parse_ini_file($this->ConfigurationPath, true);

            /** Multiline support. */
            if (is_array($this->Configuration)) {
                foreach ($this->Configuration as $CatKey => &$CatVal) {
                    if (is_array($CatVal)) {
                        foreach ($CatVal as $DirKey => &$DirVal) {
                            if (!is_string($DirVal)) {
                                continue;
                            }
                            $DirVal = str_replace(
                                ["\\\\", '\0', '\a', '\b', '\t', '\n', '\v', '\f', '\r', '\e'],
                                ["\\", "\0", "\7", "\8", "\t", "\n", "\x0B", "\x0C", "\r", "\x1B"],
                                $DirVal
                            );
                        }
                    }
                }
                unset($DirVal, $DirKey, $CatVal, $CatKey);
            }
        } elseif (preg_match('~\.ya?ml$~i', $this->ConfigurationPath)) {
            if ($Configuration = $this->readFile($this->ConfigurationPath)) {
                $this->YAML->process($Configuration, $this->Configuration);
            }
        }

        /** Load phpMussel core configuration defaults and perform fallbacks. */
        if (
            is_readable($this->AssetsPath . 'config.yml') &&
            $Configuration = $this->readFile($this->AssetsPath . 'config.yml')
        ) {
            $Defaults = [];
            $this->YAML->process($Configuration, $Defaults);
            $this->fallback($Defaults);
            $this->ConfigurationDefaults = array_merge_recursive($this->ConfigurationDefaults, $Defaults);
        }

        /** Register log paths. */
        $this->InstanceCache['LogPaths'][] = $this->Configuration['core']['scan_log'];
        $this->InstanceCache['LogPaths'][] = $this->Configuration['core']['scan_log_serialized'];
        $this->InstanceCache['LogPaths'][] = $this->Configuration['core']['error_log'];

        /** Calculate and build various paths. */
        foreach (['CachePath', 'QuarantinePath', 'SignaturesPath'] as $Path) {
            if (!$$Path) {
                if (!$VendorPath) {
                    continue;
                }
                $$Path = $VendorPath . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . 'phpmussel-' . strtolower(substr($Path, 0, -4));
            }
            if (!$this->buildPath($$Path, false)) {
                throw new \Exception(sprintf('Unable to build the path, "%s".', $$Path));
            }
            if (($End = substr($$Path, -1)) && $End !== '/' && $End !== '\\') {
                $$Path .= DIRECTORY_SEPARATOR;
            }
            $this->$Path = $$Path;
        }

        /** Fetch the IP address of the current request. */
        $this->IPAddr = (new \Maikuolan\Common\IPHeader($this->Configuration['core']['ipaddr']))->Resolution;

        /** Set timezone. */
        if (!empty($this->Configuration['core']['timezone']) && $this->Configuration['core']['timezone'] !== 'SYSTEM') {
            date_default_timezone_set($this->Configuration['core']['timezone']);
        }

        /** Revert script ident if "hide_version" is true. */
        if ($this->Configuration['core']['hide_version']) {
            $this->ScriptIdent = 'phpMussel';
        }

        /** Instantiate the request class. */
        $this->Request = new \Maikuolan\Common\Request();
        $this->Request->DefaultTimeout = $this->Configuration['core']['default_timeout'];
        if ($this->Configuration['core']['outbound_request_log'] !== '') {
            $this->Request->ObjLoggerFile = $this->buildPath($this->Configuration['core']['outbound_request_log']);
        }
        $ChannelsDataArray = [];
        $this->YAML->process($this->readFileContent($this->AssetsPath . 'channels.yml'), $ChannelsDataArray);
        $this->Request->Channels = $ChannelsDataArray ?: [];
        unset($ChannelsDataArray);
        if (!isset($this->Request->Channels['Triggers'])) {
            $this->Request->Channels['Triggers'] = [];
        }
        $this->Request->Disabled = $this->Configuration['core']['disabled_channels'];
        $this->Request->UserAgent = $this->ScriptUA;

        /** If the language directive is empty, default to English. */
        if (empty($this->Configuration['core']['lang'])) {
            $this->Configuration['core']['lang'] = 'en';
        }

        /** Load phpMussel core L10N data. */
        $this->loadL10N($this->L10NPath);

        /** Calculate instantiation time. */
        $this->Time = time() + ($this->Configuration['core']['time_offset'] * 60);

        /** Initialise the cache. */
        $this->initialiseCache();

        /**
         * Writes to the default error log.
         *
         * @return bool True on success; False on failure.
         */
        $this->Events->addHandler('final', function (): bool {
            /** Guard. */
            if (
                $this->Configuration['core']['error_log'] === '' ||
                !isset($this->InstanceCache['PendingErrorLogData']) ||
                !($File = $this->buildPath($this->Configuration['core']['error_log']))
            ) {
                return false;
            }

            $Truncate = $this->readBytes($this->Configuration['core']['truncate']);
            if (!file_exists($File) || !filesize($File) || ($Truncate && filesize($File) >= $Truncate)) {
                $WriteMode = 'wb';
                $Data = $this->L10N->getString('error_log_header') . "\n=====\n" . $this->InstanceCache['PendingErrorLogData'];
            } else {
                $WriteMode = 'ab';
                $Data = $this->InstanceCache['PendingErrorLogData'];
            }
            $Handle = fopen($File, $WriteMode);
            if (is_resource($Handle)) {
                fwrite($Handle, $Data);
                fclose($Handle);
                $this->logRotation($this->Configuration['core']['error_log']);
            }
            return true;
        });

        /**
         * Prepares any caught errors for writing to the default error log.
         *
         * @return bool True on success; False on failure.
         */
        $this->Events->addHandler('error', function (string $Data, array $Err): bool {
            /** Guard. */
            if ($this->Configuration['core']['error_log'] === '') {
                return false;
            }

            if (!isset($this->InstanceCache['PendingErrorLogData'])) {
                $this->InstanceCache['PendingErrorLogData'] = '';
            }
            $Message = sprintf(
                '[%s] Error at %s:L%d (error code %d)%s.',
                date('c', time()),
                empty($Err[2]) ? '?' : $Err[2],
                empty($Err[3]) ? 0 : $Err[3],
                empty($Err[0]) ? 0 : $Err[0],
                empty($Err[1]) ? '' : ': "' . $Err[1] . '"'
            );
            $this->InstanceCache['PendingErrorLogData'] .= $Message . "\n";
            return true;
        });
    }

    /**
     * Destruct the loader.
     *
     * @return void
     */
    public function __destruct()
    {
        /** Fire any final shutdown events. */
        if ($this->Events->assigned('final')) {
            $this->Events->fireEvent('final');
        }

        /** Restore default error handler. */
        restore_error_handler();
    }

    /**
     * Returns the content of the specified file (should only use for
     * reasonably small files).
     *
     * @param string $File The file to read.
     * @return string The file's content or an empty string on failure.
     */
    public function readFile(string $File): string
    {
        /** Guard. */
        if (!is_file($File) || !is_readable($File) || !$Filesize = filesize($File)) {
            return '';
        }

        $Handle = fopen($File, 'rb');
        if (!is_resource($Handle)) {
            return '';
        }
        $Data = fread($Handle, $Filesize);
        fclose($Handle);
        return $Data;
    }

    /**
     * Read byte value configuration directives as byte values.
     *
     * @param string $In Input.
     * @param int $Mode Operating mode. 0 for true byte values, 1 for validating.
     * @return string|int Output (return type depends on operating mode).
     */
    public function readBytes(string $In, int $Mode = 0)
    {
        $Unit = '';
        if (preg_match('/([KkMmGgTtPpOoBb]|К|к|М|м|Г|г|Т|т|П|п|Ｋ|ｋ|Ｍ|ｍ|Ｇ|ｇ|Ｔ|ｔ|Ｐ|ｐ|Б|б|Ｂ|ｂ)([OoBb]|Б|б|Ｂ|ｂ)?$/', $In, $Matches)) {
            if (preg_match('/^([Kk]|К|к)$/', $Matches[1])) {
                $Unit = 'K';
            } elseif (preg_match('/^([Mm]|М|м)$/', $Matches[1])) {
                $Unit = 'M';
            } elseif (preg_match('/^([Gg]|Г|г)$/', $Matches[1])) {
                $Unit = 'G';
            } elseif (preg_match('/^([Tt]|Т|т)$/', $Matches[1])) {
                $Unit = 'T';
            } elseif (preg_match('/^([Pp]|П|п)$/', $Matches[1])) {
                $Unit = 'P';
            }
        }
        $In = (float)$In;
        if ($Mode === 1) {
            return $Unit === '' ? $In . 'B' : $In . $Unit . 'B';
        }
        $Multiply = ['K' => 1024, 'M' => 1048576, 'G' => 1073741824, 'T' => 1099511627776, 'P' => 1125899906842620];
        if (isset($Multiply[$Unit])) {
            $In *= $Multiply[$Unit];
        }
        return (int)floor($In);
    }

    /**
     * Fix incorrect typecasting for some for some variables that sometimes default
     * to strings instead of booleans or integers.
     *
     * @param mixed $Var The variable to fix (passed by reference).
     * @param string $Type The type (or pseudo-type) to cast the variable to.
     * @return void
     */
    public function autoType(&$Var, string $Type = ''): void
    {
        if (in_array($Type, ['string', 'timezone', 'checkbox', 'url', 'email'], true)) {
            $Var = (string)$Var;
        } elseif ($Type === 'int') {
            $Var = (int)$Var;
        } elseif ($Type === 'float') {
            $Var = (float)$Var;
        } elseif ($Type === 'bool') {
            $Var = (strtolower($Var) !== 'false' && $Var);
        } elseif ($Type === 'kb') {
            $Var = $this->readBytes((string)$Var, 1);
        } else {
            $LVar = strtolower($Var);
            if ($LVar === 'true') {
                $Var = true;
            } elseif ($LVar === 'false') {
                $Var = false;
            } elseif ($Var !== true && $Var !== false) {
                $Var = (int)$Var;
            }
        }
    }

    /**
     * Performs fallbacks and autotyping for missing configuration directives.
     *
     * @param array $Fallbacks The fallback source.
     * @return void
     */
    public function fallback(array $Fallbacks): void
    {
        foreach ($Fallbacks as $KeyCat => $DCat) {
            if (!isset($this->Configuration[$KeyCat])) {
                $this->Configuration[$KeyCat] = [];
            }
            if (isset($Cat)) {
                unset($Cat);
            }
            $Cat = &$this->Configuration[$KeyCat];
            if (!is_array($DCat)) {
                continue;
            }
            foreach ($DCat as $DKey => $DData) {
                if (!isset($Cat[$DKey]) && isset($DData['default'])) {
                    $Cat[$DKey] = $DData['default'];
                }
                if (isset($Dir)) {
                    unset($Dir);
                }
                if (!isset($Cat[$DKey])) {
                    $Cat[$DKey] = '';
                }
                $Dir = &$Cat[$DKey];
                if (isset($DData['value_preg_filter']) && is_array($DData['value_preg_filter'])) {
                    foreach ($DData['value_preg_filter'] as $FilterKey => $FilterValue) {
                        $Dir = preg_replace($FilterKey, $FilterValue, $Dir);
                    }
                }
                if (isset($DData['type'])) {
                    $this->autoType($Dir, $DData['type']);
                }
            }
        }
    }

    /**
     * Load L10N data.
     *
     * @param string $Path Where to find the L10N data to load.
     * @return void
     */
    public function loadL10N(string $Path = ''): void
    {
        if ($this->Configuration['core']['lang'] === 'en') {
            $Primary = $this->readFile($Path . 'en.yml');
            $Fallback = '';
        } else {
            if (($Primary = $this->readFile($Path . $this->Configuration['core']['lang'] . '.yml')) === '') {
                if (isset($this->ConfigurationDefaults['core']['lang']['defer'][$this->Configuration['core']['lang']])) {
                    $Primary = $this->readFile($Path . $this->ConfigurationDefaults['core']['lang']['defer'][$this->Configuration['core']['lang']] . '.yml');
                }
                if ($Primary === '') {
                    $Try = preg_replace('~-.*$~', '', $this->Configuration['core']['lang']);
                    $Primary = $this->readFile($Path . $Try . '.yml');
                }
            }
            $Fallback = $this->readFile($Path . 'en.yml');
        }
        if ($Primary !== '') {
            $Accepted = $this->ConfigurationDefaults['core']['lang']['assume'][$this->Configuration['core']['lang']] ?? $this->Configuration['core']['lang'];
            $Arr = [];
            $this->YAML->process($Primary, $Arr);
            $Primary = $Arr;
        } else {
            $Accepted = '';
            $Primary = [];
        }
        if ($this->L10NAccepted === '' && $Accepted !== '') {
            $this->L10NAccepted = $Accepted;
        }
        if ($Fallback !== '') {
            $Arr = [];
            $this->YAML->process($Fallback, $Arr);
            $Fallback = $Arr;
        } else {
            $Fallback = [];
        }

        /** Instantiate the L10N object, or append to the instance if it already exists. */
        if ($this->L10N instanceof \Maikuolan\Common\L10N && is_array($this->L10N->Data)) {
            if (!empty($Primary) && is_array($this->L10N->Data)) {
                $this->L10N->Data = array_merge($this->L10N->Data, $Primary);
            }
            if (!empty($Fallback) && is_array($this->L10N->Fallback)) {
                $this->L10N->Fallback = array_merge($this->L10N->Fallback, $Fallback);
            }
        } else {
            $this->L10N = new \Maikuolan\Common\L10N($Primary, $Fallback);
            if ($this->Configuration['core']['lang'] === 'en') {
                $this->L10N->autoAssignRules('en-AU');
            } else {
                $this->L10N->autoAssignRules($this->L10NAccepted, 'en-AU');
            }
        }

        /** Load client-specified L10N data if possible. */
        if (!$this->Configuration['core']['lang_override'] || empty($_SERVER['HTTP_ACCEPT_LANGUAGE'])) {
            if (!($this->ClientL10N instanceof \Maikuolan\Common\L10N)) {
                $this->ClientL10N = &$this->L10N;
            }
        } else {
            $Try = explode(',', $_SERVER['HTTP_ACCEPT_LANGUAGE'], 20);
            foreach ($Try as $Accepted) {
                $Accepted = preg_replace(['~;.*$~', '~[^-A-Za-z]~'], '', $Accepted);
                $ForAutoAssign = $Accepted;
                $Primary = '';
                $IsSameAs = false;
                if ($this->L10NAccepted === $Accepted) {
                    $IsSameAs = true;
                    break;
                }
                if (isset($this->ConfigurationDefaults['core']['lang']['defer'][$Accepted])) {
                    if ($this->L10NAccepted === $this->ConfigurationDefaults['core']['lang']['defer'][$Accepted]) {
                        $IsSameAs = true;
                        break;
                    }
                    if (is_readable($Path . $this->ConfigurationDefaults['core']['lang']['defer'][$Accepted] . '.yml')) {
                        $Primary = $this->readFile($Path . $this->ConfigurationDefaults['core']['lang']['defer'][$Accepted] . '.yml');
                        break;
                    }
                }
                if (is_readable($Path . $Accepted . '.yml')) {
                    $Primary = $this->readFile($Path . $Accepted . '.yml');
                    break;
                }
                $Accepted = strtolower(preg_replace('~-.*$~', '', $Accepted));
                if ($this->Configuration['core']['lang'] === $Accepted) {
                    $Accepted = $this->L10NAccepted;
                    $IsSameAs = true;
                    break;
                }
                if (is_readable($Path . $Accepted . '.yml')) {
                    if (isset($this->ConfigurationDefaults['core']['lang']['assume'][$Accepted])) {
                        $Accepted = $this->ConfigurationDefaults['core']['lang']['assume'][$Accepted];
                        $ForAutoAssign = $Accepted;
                    }
                    $Primary = $this->readFile($Path . $Accepted . '.yml');
                    break;
                }
            }

            /** Process client-specified L10N data. */
            if ($IsSameAs) {
                if (!($this->ClientL10N instanceof \Maikuolan\Common\L10N)) {
                    $this->ClientL10N = &$this->L10N;
                }
            } elseif ($Primary !== '') {
                $Arr = [];
                if ($this->ClientL10NAccepted === '' && $Accepted !== '') {
                    $this->ClientL10NAccepted = $Accepted;
                }
                $this->YAML->process($Primary, $Arr);
                if ($this->ClientL10N instanceof \Maikuolan\Common\L10N && is_array($this->ClientL10N->Data)) {
                    $this->ClientL10N->Data = array_merge($this->ClientL10N->Data, $Arr);
                } else {
                    $this->ClientL10N = new \Maikuolan\Common\L10N($Arr, $this->L10N);
                    $this->ClientL10N->autoAssignRules($ForAutoAssign);
                }
            } elseif (!($this->ClientL10N instanceof \Maikuolan\Common\L10N)) {
                $this->ClientL10N = new \Maikuolan\Common\L10N([], $this->L10N);
                $this->ClientL10N->autoAssignRules($ForAutoAssign);
            }
        }

        /** Fallback for missing accepted client L10N choice. */
        if ($this->ClientL10NAccepted === '') {
            $this->ClientL10NAccepted = $this->L10NAccepted;
        }
    }

    /**
     * Replaces some date/time symbols with the information they represent.
     *
     * @param int $Time A unix timestamp.
     * @param string|array $In An input or an array of inputs to manipulate.
     * @return string|array The adjusted input(/s).
     */
    public function timeFormat(int $Time, $In)
    {
        /** Guard. */
        if (!is_array($In) && (strpos($In, '{') === false || strpos($In, '}') === false)) {
            return $In;
        }

        $Time = date('dmYHisDMP', $Time);
        $Values = [
            'dd' => substr($Time, 0, 2),
            'mm' => substr($Time, 2, 2),
            'yyyy' => substr($Time, 4, 4),
            'yy' => substr($Time, 6, 2),
            'hh' => substr($Time, 8, 2),
            'ii' => substr($Time, 10, 2),
            'ss' => substr($Time, 12, 2),
            'Day' => substr($Time, 14, 3),
            'Mon' => substr($Time, 17, 3),
            'tz' => substr($Time, 20, 3) . substr($Time, 24, 2),
            't:z' => substr($Time, 20, 6)
        ];
        $Values['d'] = (int)$Values['dd'];
        $Values['m'] = (int)$Values['mm'];
        if (is_array($In)) {
            return array_map(function (string $Item) use (&$Values): string {
                return $this->parse($Values, $Item);
            }, $In);
        }
        return $this->parse($Values, $In);
    }

    /**
     * Replaces encapsulated substrings within a string using the values of the
     * corresponding elements within an array.
     *
     * @param array $Needles An array containing replacement values.
     * @param string $Haystack The string to work with.
     * @param bool $L10N Whether to parse L10N placeholders found in the haystack.
     * @return string The string with its encapsulated substrings replaced.
     */
    public function parse(array $Needles, string $Haystack = '', bool $L10N = false): string
    {
        if ($Haystack === '') {
            return '';
        }
        if ($L10N && preg_match_all('~\{([A-Za-z\d_ -]+)\}~', $Haystack, $Matches)) {
            foreach (array_unique($Matches[1]) as $Key) {
                if (($Value = $this->L10N->getString($Key)) !== '') {
                    $Haystack = str_replace('{' . $Key . '}', $Value, $Haystack);
                }
            }
        }
        foreach ($Needles as $Key => $Value) {
            if (!is_array($Value) && $Value !== null) {
                $Haystack = str_replace('{' . $Key . '}', $Value, $Haystack);
            }
        }
        return $Haystack;
    }

    /**
     * Pseudonymise an IP address (reduce IPv4s to /24s and IPv6s to /32s).
     *
     * @param string $IP An IP address.
     * @return string A pseudonymised IP address.
     */
    public function pseudonymiseIP(string $IP): string
    {
        if (($CPos = strpos($IP, ':')) !== false) {
            $Parts = [(substr($IP, 0, $CPos) ?: ''), (substr($IP, $CPos +1) ?: '')];
            if (($CPos = strpos($Parts[1], ':')) !== false) {
                $Parts[1] = substr($Parts[1], 0, $CPos) ?: '';
            }
            $Parts = $Parts[0] . ':' . $Parts[1] . '::x';
            return str_replace(':::', '::', $Parts);
        }
        return preg_replace(
            '/^([01]?\d{1,2}|2[0-4]\d|25[0-5])\.([01]?\d{1,2}|2[0-4]\d|25[0-5])\.([01]?\d{1,2}|2[0-4]\d|25[0-5])\.([01]?\d{1,2}|2[0-4]\d|25[0-5])$/i',
            '\1.\2.\3.x',
            $IP
        );
    }

    /**
     * Build any missing parts of the given path, apply date/time replacements,
     * and check whether the path is writable.
     *
     * @param string $Path The path we're building for.
     * @param bool $PointsToFile Whether the path ultimately points to a file
     *      or a directory.
     * @return string If all missing parts were successfully built and the
     *      final rebuilt path is writable, returns the final rebuilt path.
     *      Otherwise, returns an empty string.
     */
    public function buildPath(string $Path, bool $PointsToFile = true): string
    {
        /** Input guard. */
        if ($Path === '') {
            return '';
        }

        /** Applies time/date replacements. */
        $Path = $this->timeFormat($this->Time, $Path);

        /** We'll skip is_dir/mkdir calls if open_basedir is populated (to avoid PHP bug #69240). */
        $Restrictions = strlen(ini_get('open_basedir')) > 0;

        /** Split path into steps. */
        $Steps = preg_split('~[\\\/]~', $Path, -1, PREG_SPLIT_NO_EMPTY);

        /** Separate file from path. */
        $File = $PointsToFile ? array_pop($Steps) : '';

        /** Build directories. */
        foreach ($Steps as $Step) {
            if (!isset($Rebuilt)) {
                $Rebuilt = preg_match('~^[\\\/]~', $Path) ? DIRECTORY_SEPARATOR . $Step : $Step;
            } else {
                $Rebuilt .= DIRECTORY_SEPARATOR . $Step;
            }
            if (preg_match('~^\.+$~', $Step)) {
                continue;
            }
            if (!$Restrictions && !is_dir($Rebuilt) && !mkdir($Rebuilt)) {
                return '';
            }
        }

        /** Ensure rebuilt is defined. */
        if (!isset($Rebuilt)) {
            $Rebuilt = '';
        }

        /** Return an empty string if the final rebuilt path isn't writable. */
        if (!is_writable($Rebuilt)) {
            return '';
        }

        /** Append file. */
        if ($File) {
            $Rebuilt .= ($Rebuilt ? DIRECTORY_SEPARATOR : '') . $File;
        }

        /** Return the final rebuilt path. */
        return $Rebuilt;
    }

    /**
     * Gets substring from haystack prior to the first occurrence of needle.
     *
     * @param string $Haystack The haystack.
     * @param string $Needle The needle.
     * @return string The substring.
     */
    public function substrBeforeFirst(string $Haystack, string $Needle): string
    {
        return $Needle === '' ? '' : substr($Haystack, 0, strpos($Haystack, $Needle));
    }

    /**
     * Gets substring from haystack after the first occurrence of needle.
     *
     * @param string $Haystack The haystack.
     * @param string $Needle The needle.
     * @return string The substring.
     */
    public function substrAfterFirst(string $Haystack, string $Needle): string
    {
        return !($Length = strlen($Needle)) ? '' : substr($Haystack, strpos($Haystack, $Needle) + $Length);
    }

    /**
     * Gets substring from haystack prior to the last occurrence of needle.
     *
     * @param string $Haystack The haystack.
     * @param string $Needle The needle.
     * @return string The substring.
     */
    public function substrBeforeLast(string $Haystack, string $Needle): string
    {
        return $Needle === '' ? '' : substr($Haystack, 0, strrpos($Haystack, $Needle));
    }

    /**
     * Gets substring from haystack after the last occurrence of needle.
     *
     * @param string $Haystack The haystack.
     * @param string $Needle The needle.
     * @return string The substring.
     */
    public function substrAfterLast(string $Haystack, string $Needle): string
    {
        return !($Length = strlen($Needle)) ? '' : substr($Haystack, strrpos($Haystack, $Needle) + $Length);
    }

    /**
     * Reads and returns the contents of files.
     *
     * @param string $File The path and the name of the file to read.
     * @return string The file's content, or an empty string on failure.
     */
    public function readFileContent(string $File): string
    {
        /** Guard. */
        if ($File === '' || !is_file($File) || !is_readable($File)) {
            return '';
        }

        $Data = file_get_contents($File);
        return is_string($Data) ? $Data : '';
    }

    /**
     * Reads and returns the contents of GZ-compressed files.
     *
     * @param string $File The file to read.
     * @return string The file's content, or an empty string on failure.
     */
    public function readFileContentGZ(string $File): string
    {
        /** Guard. */
        if ($File === '' || !is_file($File) || !is_readable($File) || !$Filesize = filesize($File)) {
            return '';
        }

        /** Calculate this file's blocks to read. */
        $BlocksToRead = ($Filesize && $this->Blocksize) ? ceil($Filesize / $this->Blocksize) : 0;

        $Data = '';
        if ($BlocksToRead > 0) {
            $Handle = gzopen($File, 'rb');
            if (!is_resource($Handle)) {
                return '';
            }
            $Done = 0;
            while (!gzeof($GZLogHandler) && $Done < $BlocksToRead) {
                $Data .= gzread($Handle, $this->Blocksize);
                $Done++;
            }
            gzclose($Handle);
        }
        return $Data;
    }

    /**
     * A simple file() wrapper that checks for the existence of files before
     * attempting to read them, in order to avoid warnings about non-existent
     * files, with a normalised return value.
     *
     * @param string $Filename Refer to the description for file().
     * @param int $Flags Refer to the description for file().
     * @param resource|null $Context Refer to the description for file().
     * @return array The file's contents or an empty array on failure.
     */
    public function readFileAsArray(string $Filename, int $Flags = 0, $Context = null): array
    {
        /** Guard. */
        if (!is_file($Filename) || !is_readable($Filename) || !$Filesize = filesize($Filename)) {
            return [];
        }

        if (!is_resource($Context)) {
            $Output = !$Flags ? file($Filename) : file($Filename, $Flags);
        } else {
            $Output = file($Filename, $Flags, $Context);
        }
        return is_array($Output) ? $Output : [];
    }

    /**
     * A simple safety wrapper for unpack.
     *
     * @param string $Format Anything supported by unpack (usually "S" or "*l").
     * @param string $Data The data to be unpacked.
     * @return array The unpacked data (or an empty array upon failure).
     */
    public function unpackSafe(string $Format, string $Data): array
    {
        if (strlen($Data) < 1) {
            return [];
        }
        return unpack($Format, $Data) ?: [];
    }

    /**
     * If input isn't an array, make it so. Remove empty elements.
     *
     * @param mixed $Input
     * @return void
     */
    public function arrayify(&$Input): void
    {
        if (!is_array($Input)) {
            $Input = [$Input];
        }
        $Input = array_filter($Input);
    }

    /**
     * GZ-compress a file (used by log rotation).
     *
     * @param string $File The file to GZ-compress.
     * @return bool True on success; False on failure.
     */
    public function gZCompressFile(string $File): bool
    {
        /** Guard. */
        if ($File === '' || !is_file($File) || !is_readable($File)) {
            return false;
        }

        $Handle = fopen($File, 'rb');
        if (!is_resource($Handle)) {
            return false;
        }
        $HandleGZ = gzopen($File . '.gz', 'wb');
        if (!is_resource($HandleGZ)) {
            return false;
        }
        while (!feof($Handle)) {
            $Data = fread($Handle, $this->Blocksize);
            gzwrite($HandleGZ, $Data);
        }
        gzclose($HandleGZ);
        fclose($Handle);
        return true;
    }

    /**
     * Checks whether the specified directory is empty.
     *
     * @param string $Directory The directory to check.
     * @return bool True if empty; False if not empty.
     */
    public function isDirEmpty(string $Directory): bool
    {
        return !((new \FilesystemIterator($Directory))->valid());
    }

    /**
     * Deletes empty directories (used by some front-end methods and log rotation).
     *
     * @param string $Dir The directory to delete.
     * @return void
     */
    public function deleteDirectory(string $Dir): void
    {
        while (strrpos($Dir, DIRECTORY_SEPARATOR) !== false) {
            $Dir = substr($Dir, 0, strrpos($Dir, DIRECTORY_SEPARATOR));
            if (!is_dir($Dir) || !$this->isDirEmpty($Dir)) {
                break;
            }
            rmdir($Dir);
        }
    }

    /**
     * Log rotation.
     *
     * @param string $Pattern What to identify log files by (should be supplied via the relevant logging directive).
     * @return bool False when log rotation is disabled or errors occur; True otherwise.
     */
    public function logRotation(string $Pattern): bool
    {
        $Limit = $this->Configuration['core']['log_rotation_limit'] ?? 0;
        $Action = $this->Configuration['core']['log_rotation_action'] ?? '';
        if ($Limit < 1 || ($Action !== 'Delete' && $Action !== 'Archive')) {
            return false;
        }
        $Arr = [];
        if ((strpos($Pattern, '{') === false && strpos($Pattern, '}') === false)) {
            if (is_file($Pattern)) {
                $Arr[] = realpath($Pattern);
            }
        } else {
            foreach ($this->resolvePaths($Pattern, true, false) as $Item) {
                $Arr[] = $Item;
            }
        }
        $Files = [];
        foreach ($Arr as $Item) {
            if ($Item && is_file($Item) && is_readable($Item)) {
                $Files[$Item] = filemtime($Item);
            }
        }
        $Count = count($Files);
        $Err = 0;
        if ($Count > $Limit) {
            asort($Files, SORT_NUMERIC);
            foreach ($Files as $Item => $Modified) {
                if ($Action === 'Archive') {
                    $Err += !$this->gZCompressFile($Item);
                }
                $Err += !unlink($Item);
                $this->deleteDirectory($Item);
                $Count--;
                if (!($Count > $Limit)) {
                    break;
                }
            }
        }
        return $Err === 0;
    }

    /**
     * Yield real paths from possible paths using patterns.
     *
     * @param string $Base The path base.
     * @param bool $LastIsFile Whether the last part of the path is a file.
     * @param bool $GZ Whether to append GZ to the pattern.
     * @return \Generator
     */
    public function resolvePaths(string $Base, bool $LastIsFile = true, bool $GZ = true): \Generator
    {
        $Steps = preg_split('~[\\\/]~', $Base, -1, PREG_SPLIT_NO_EMPTY);
        $LastStep = $LastIsFile ? array_pop($Steps) : '';
        $BaseFrom = '';
        $Remainder = '';
        foreach ($Steps as $Step) {
            if (!$Remainder && strpos($Step, '{') === false && strpos($Step, '}') === false) {
                $BaseFrom .= $Step . DIRECTORY_SEPARATOR;
                continue;
            }
            $Remainder .= ($Remainder ? DIRECTORY_SEPARATOR : '') . $Step;
        }
        if (!$BaseFrom || !is_dir($BaseFrom) || !is_readable($BaseFrom)) {
            return;
        }
        if ($Remainder && $LastStep) {
            $LastStep = DIRECTORY_SEPARATOR . $LastStep;
        }
        $Steps = preg_replace(
            ['~\\\{(?:dd|mm|yy|hh|ii|ss)\\\}~i', '~\\\{yyyy\\\}~i', '~\\\{(?:Day|Mon)\\\}~i', '~\\\{tz\\\}~i', '~\\\{t\\\:z\\\}~i'],
            ['\d{2}', '\d{4}', '\w{3}', '.{1,2}\d{4}', '.{1,2}\d{2}\:\d{2}'],
            preg_quote($Remainder) . ($LastStep ? preg_quote($LastStep) . ($GZ ? '(?:\.gz)?' : '') . '$' : '')
        );
        $Pattern = '~^' . preg_quote($BaseFrom) . $Steps . '~i';
        $List = new \RecursiveIteratorIterator(new \RecursiveDirectoryIterator($BaseFrom), \RecursiveIteratorIterator::SELF_FIRST);
        foreach ($List as $Name => $SplData) {
            if (preg_match($Pattern, $Name) && ($Name = realpath($Name))) {
                yield $Name;
            }
        }
    }

    /**
     * A simple safety wrapper for hex2bin.
     *
     * @param string $Data Hexadecimally encoded data.
     * @return string The decoded data.
     */
    public function hexSafe(string $Data): string
    {
        return ($Data && !preg_match('/[^\da-f]/i', $Data) && !(strlen($Data) % 2)) ? hex2bin($Data) : '';
    }

    /**
     * Fetch favicon.
     *
     * @return string The phpMussel favicon (raw PNG data).
     */
    public function getFavicon(): string
    {
        return $this->readFile($this->AssetsPath . 'favicon.png');
    }

    /**
     * Update the configuration.
     *
     * @return bool Whether succeeded or failed.
     */
    public function updateConfiguration(): bool
    {
        if (strtolower(substr($this->ConfigurationPath, -4)) === '.ini') {
            $Reconstructed = '';
            foreach ($this->Configuration as $CatKey => $CatValue) {
                if (!is_array($CatValue)) {
                    continue;
                }
                $Reconstructed .= sprintf("[%s]\r\n", $CatKey);
                foreach ($CatValue as $DirKey => $DirValue) {
                    if (!is_scalar($DirValue)) {
                        continue;
                    }
                    if ($DirValue === true) {
                        $Reconstructed .= sprintf("%s=true\r\n", $DirKey);
                    } elseif ($DirValue === false) {
                        $Reconstructed .= sprintf("%s=false\r\n", $DirKey);
                    } elseif (is_string($DirValue)) {
                        /** Multiline support. */
                        $DirValue = preg_replace('~[^\x00-\xFF]~', '', str_replace(
                            ["\\", "\0", "\7", "\8", "\t", "\n", "\x0B", "\x0C", "\r", "\x1B"],
                            ["\\\\", '\0', '\a', '\b', '\t', '\n', '\v', '\f', '\r', '\e'],
                            $DirValue
                        ));

                        $Reconstructed .= sprintf("%s='%s'\r\n", $DirKey, $DirValue);
                    } else {
                        $Reconstructed .= sprintf("%s=%s\r\n", $DirKey, $DirValue);
                    }
                }
            }
        } elseif (preg_match('~\.ya?ml$~i', $this->ConfigurationPath)) {
            $Reconstructed = $this->YAML->reconstruct($this->Configuration);
        } else {
            return false;
        }
        $Handle = fopen($this->ConfigurationPath, 'wb');
        if (!is_resource($Handle)) {
            return false;
        }
        $Err = fwrite($Handle, $Reconstructed);
        fclose($Handle);
        return $Err !== false;
    }

    /**
     * Load shorthand data.
     *
     * @return bool Whether succeeded or failed.
     */
    public function loadShorthandData(): bool
    {
        if (isset($this->InstanceCache['shorthand.yml'])) {
            return true;
        }
        if (!$ShorthandData = $this->readFile($this->AssetsPath . 'shorthand.yml')) {
            return false;
        }
        $this->InstanceCache['shorthand.yml'] = [];
        $this->YAML->process($ShorthandData, $this->InstanceCache['shorthand.yml']);
        return true;
    }

    /**
     * Writes to $HashReference, and performs any other needed hit-related actions.
     *
     * @param string $Hash The hash of the item which had a positive hit.
     * @param int $Size The size of the item which had a positive hit.
     * @param string $Name The name of the item which had a positive hit.
     * @param string $Text A human-readable explanation of the hit.
     * @param int $Code The integer results of the scan.
     * @param int $Depth The current depth of the scan process.
     * @return void
     */
    public function atHit(string $Hash, int $Size = -1, string $Name = '', string $Text = '', int $Code = 2, int $Depth = 0): void
    {
        /** Fallback for missing item hash. */
        if ($Hash === '') {
            $Hash = $this->L10N->getString('data_not_available');
        }

        /** Fallback for missing item name. */
        if ($Name === '') {
            $Name = $this->L10N->getString('data_not_available');
        }

        /** Ensure that $Text doesn't break lines and clean it up. */
        $Text = preg_replace('~[\x00-\x1F]~', '', $Text);

        /** Generate hash reference and key for various arrays to be populated. */
        $HashReference = sprintf('%s:%d:%s', $Hash, $Size, $Name);
        if (strpos($this->HashReference, $HashReference . "\n") === false) {
            $this->HashReference .= $HashReference . "\n";
        }

        $TextLength = strlen($Text);

        /** Scan results as text. */
        if ($TextLength && isset($this->ScanResultsText[$HashReference]) && strlen($this->ScanResultsText[$HashReference])) {
            $this->ScanResultsText[$HashReference] .= $this->L10N->getString('grammar_spacer') . $Text;
        } else {
            $this->ScanResultsText[$HashReference] = $Text;
        }

        /** Scan results as integers. */
        if (empty($this->ScanResultsIntegers[$HashReference]) || $this->ScanResultsIntegers[$HashReference] !== 2) {
            $this->ScanResultsIntegers[$HashReference] = $Code;
        }

        /** Increment detections count. */
        if ($Code !== 0 && $Code !== 1) {
            if (isset($this->InstanceCache['DetectionsCount'])) {
                $this->InstanceCache['DetectionsCount']++;
            } else {
                $this->InstanceCache['DetectionsCount'] = 1;
            }
        }

        /** Indenting to apply for the formatted scan results . */
        $Indent = str_pad('→ ', ($Depth < 1 ? 4 : ($Depth * 3) + 4), '─', STR_PAD_LEFT);

        /** Fallback for missing text for formatted text. */
        if (!$TextLength) {
            if ($Code === 0) {
                $Text = sprintf(
                    $this->L10N->getString('grammar_exclamation_mark'),
                    sprintf($this->L10N->getString('x_does_not_exist'), $Name)
                );
            } elseif ($Code === 1) {
                $Text = $this->L10N->getString('scan_no_problems_found');
            } else {
                $Text = $this->L10N->getString('data_not_available');
            }
        }

        /** Scan results as formatted text. */
        $this->ScanResultsFormatted .= $Indent . $Text . "\n";

        /** Update flags. */
        $this->InstanceCache['CheckWasLast'] = false;
    }

    /**
     * Initialise the cache.
     *
     * @throws Exception if using flatfiles for caching and if an appropriate
     *      cache directory hasn't been specified or can't be written to.
     * @return void
     */
    private function initialiseCache(): void
    {
        /** Exit early if already initialised. */
        if ($this->Cache instanceof \Maikuolan\Common\Cache) {
            return;
        }

        /** Create new cache object. */
        $this->Cache = new \Maikuolan\Common\Cache();
        $this->Cache->Prefix = $this->Configuration['supplementary_cache_options']['prefix'];
        $this->Cache->EnableAPCu = $this->Configuration['supplementary_cache_options']['enable_apcu'];
        $this->Cache->EnableMemcached = $this->Configuration['supplementary_cache_options']['enable_memcached'];
        $this->Cache->EnableRedis = $this->Configuration['supplementary_cache_options']['enable_redis'];
        $this->Cache->EnablePDO = $this->Configuration['supplementary_cache_options']['enable_pdo'];
        $this->Cache->MemcachedHost = $this->Configuration['supplementary_cache_options']['memcached_host'];
        $this->Cache->MemcachedPort = $this->Configuration['supplementary_cache_options']['memcached_port'];
        $this->Cache->RedisHost = $this->Configuration['supplementary_cache_options']['redis_host'];
        $this->Cache->RedisPort = $this->Configuration['supplementary_cache_options']['redis_port'];
        $this->Cache->RedisTimeout = $this->Configuration['supplementary_cache_options']['redis_timeout'];
        $this->Cache->PDOdsn = $this->Configuration['supplementary_cache_options']['pdo_dsn'];
        $this->Cache->PDOusername = $this->Configuration['supplementary_cache_options']['pdo_username'];
        $this->Cache->PDOpassword = $this->Configuration['supplementary_cache_options']['pdo_password'];

        /** Assign cache path. */
        if ($this->CachePath) {
            $this->Cache->FFDefault = $this->CachePath . DIRECTORY_SEPARATOR . 'cache.dat';
        }

        /** Attempt to connect. */
        if (!$this->Cache->connect()) {
            throw new \Exception('Cache connect failed.');
        }
    }
}
